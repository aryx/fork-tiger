\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things. Actually I re-lpized
%this document so here is what I think is now better:
% - get a breath overview of the core DS first
% - LP split things (environment.t, Ast, vartype ...) so can expose
%   first a simpler version
% - get the main functions overview first, the main types
% - AST is put closer to the grammar (update: actually was bad, but
%   at least I aspectized a few constructions like Spawn, exns)
% - I reordered AST elts, for instance CONST is before BINOP.

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand compilers:
% - mutual recursivity handling (list of things together, as in ocaml)
%   alt: forward decl as in C
% - scope handling (global for types only, as in ocaml)
%   alt: mess as in C where structures can be nested which leads to
%   complex edge cases. KISS!

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Tiger Compiler Frontend [[tigerc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Paul Govereau
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a compiler.
% frontend
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% choose tiger because very very simple.

%% vs original tigerc.pdf manual? no file/module fixed boundaries, so
%% can LP-split and aspectize AST elements for instances.

%% Hmm not redundant with Compiler.nw and even now OCaml.nw? Maybe but
%% maybe it can help me to first have a cleaner and simpler compiler,
%% so maybe making this manual can improve later Compiler.nw and OCaml.nw.
%% Can also see a simpler GC, which again can improve later OCaml.nw.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gcc
\item clang
\end{itemize}

% other:
% - blue? also a toy language for learning

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Paul Govereau, so
those parts are copyright by him.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Compiler frontend principles}

\section{[[tigerc]] services}

<<function Option.usage>>=
let rec usage() = 
  Arg.usage options "Usage:";
  exit 0;
@
% tigerc [options] <inputfile> > <c--file> where options are:
% or even tigerc < inputfile > outputfile

\section{[[helloworld.tig]]}

% demos/hello.tig

<<demos/hello.tig>>=
/* hello world */ 
let
  var a := "Hello, world.\n"
in 
  print(a)
end
@


\section{Input Tiger language}

% toy language:
%  - no modules (no qualifier), so name resolution simple (even though
%    scoped/nested language), and no linking really
%  - no float
%  - some form of type inference :) no need to declare type of VarDec

\section{Output C-- language}

\section{Code organization}

\section{Software architecture}

% classic compiler archi:
% lexer -> parser -> typechecker&IR-generator -> c-- generator 
% and on the side have runtime and stdlib "linked" with generated file.

%###############################################################################

\chapter{Core Data Structures}

\section{Abstract syntax tree}

%note: actually I put the main constructors below. I did that in Ocaml.nw
% and it's better I think. AST is a really core DS, we can't wait to
% see the grammar to get an idea of what is the language. Anyway if we
% do not put the main cases here, it's
% weird after in Type section to have RECORD, ARRAY, etc because
% we have no idea where they come from. Same for IR tree.

\subsection{Positions}

<<type Ast.pos>>=
type pos = int 
@
% for error reporting, int = charpos, see Error appendix
% and the charpos -> line mapping table

%alt: below he has added pos as an extra tuple element. Alternatives are:
% the 'a wrap tech in pfff, the record_expr in OCaml.nw, the
% extra constructor ExpPos, etc.

%alt: then alt to the line mapping table are:
% have all info in the wrap in pfff, the linenum.mll in OCaml.nw, etc.

\subsection{Names}

<<type Ast.symbol>>=
type symbol = Symbol.symbol
@
% see below, =~ unique string
%less: rename name? or ident?

% for identifiers and also type names
%less: same namespace?

\subsection{Declarations}

% defs
<<type Ast.dec>>=
type dec =
| VarDec       of symbol * symbol option * exp * pos
| TypeDec      of (symbol * ty * pos) list
| FunctionDec  of (symbol * field list * symbol option * exp * pos) list
<<[[Ast.dec]] cases>>
@
% list for TypeDec and FunctionDec so can have mutually recursive things
% VarDec symbol option? optional type
% FunctionDec symbol option? optional return type
% less: have a symboltype?

<<type Ast.field>>=
and field = (symbol * symbol * pos)
@
% symbol?? for type definition? so need to introduce indirect
% name for everything?

%ex? dump? actually have a -dump_ast!

\subsection{Expressions}

% uses
<<type Ast.exp>>=
and exp =
| NilExp
| IntExp    of int
| StringExp of string * pos

| VarExp    of var

| OpExp     of exp * oper * exp * pos
| CallExp   of symbol * exp list * pos

| RecordExp of symbol * (symbol * exp * pos) list * pos
| ArrayExp  of symbol * exp * exp * pos

| LetExp    of dec list * exp * pos

<<[[Ast.exp]] statement cases>>
<<[[Ast.exp]] cases>>
@
% also include stmt, expression language!
%ex?

%Ast.var here? =~ lvalue
%Ast.oper here?

\subsection{Statements}

<<[[Ast.exp]] statement cases>>=
| AssignExp of var * exp * pos
| SeqExp    of exp list * pos
| IfExp     of exp * exp * exp option * pos
| WhileExp  of exp * exp * pos
| ForExp    of symbol * exp * exp * exp * pos
| BreakExp  of pos
@

\subsection{Types}

<<type Ast.ty>>=
and ty =
| NameTy   of symbol * pos
| RecordTy of field list
| ArrayTy  of symbol * pos
@
% namety can be also builtin types!
% no size in ArrayTy, lose information when type

%ex?


\section{Type system}
% and the environment?

<<type Environment.vartype>>=
type vartype =
  (* basic types *)
  | UNIT
  | INT
  | STRING

  (* aggregate types *)
  | ARRAY  of vartype
  | RECORD of (Symbol.symbol * vartype) list

  (* other types *)
  <<[[Environment.vartype]] cases>>
@ 

%XXX
<<[[Environment.vartype]] cases>>=
| NIL
| ANY
@
% NIL?
% ANY?

\section{Symbol table}
% Scope system

% for use/def checking, lookup attributes, etc. classic.

\subsection{Unique symbols}

<<type Symbol.symbol>>=
type symbol = string * int
@
% int? a stamp to make sure things are unique
% will be used for many things, for many "namespaces"
%  - ident
%  - typename
%  - label
%  - temps

%note: no qualifier, no module system, no linking modules.




<<global Symbol.nextsym>>=
let nextsym = ref 0
@

<<global Symbol.hashtable>>=
let (hashtable: (string, int) Hashtbl.t) = Hashtbl.create 128
@
% get the current stamp given a symbol name

<<function Symbol.name>>=
let name = fst
@
<<function Symbol.uid>>=
let uid  = snd
@
%uid? unique id

% both a constructor and accessor
<<function Symbol.symbol>>=
let symbol name =
  try 
    let uid = Hashtbl.find hashtable name in 
    (name,uid)
  with Not_found ->
    incr nextsym; 
    Hashtbl.add hashtable name !nextsym;
    (name, !nextsym)
@
%todo: how this function is used? a bit weird to imagine

\subsection{Symbol table}

% nested scope so have a parent
<<type Symbol.table>>=
type 'a table = {
    tbl    : (symbol, 'a) Hashtbl.t;
    <<[[Symbol.table]] other fields>>
  }
@
% usually Ast.ty table; or Ast.ty Env.enventry table.


<<function Symbol.enter>>=
let enter env sym v =
  if Hashtbl.mem env.tbl sym
  then failwith "Compiler error: symbol table duplicate entry"
  else Hashtbl.add env.tbl sym v
@

<<function Symbol.mem>>=
let mem env sym = 
  Hashtbl.mem env.tbl sym
@


<<constructor Symbol.create>>=
let create l =
  let env = {
    tbl = Hashtbl.create 20;
    level = 0;
    parent = None
  } in
  l |> List.iter (fun (key, data) -> enter env (symbol key) data);
  env
@

\subsection{Scopes}

<<[[Symbol.table]] other fields>>=
parent : 'a table option;
@


% different from mem() we've seen above
<<function Symbol.look>>=
let rec look env sym =
  try Hashtbl.find env.tbl sym
  with Not_found -> 
    (match env.parent with
    | None -> raise Not_found
    | Some e -> look e sym
    )
@


<<constructor Symbol.new_scope>>=
let new_scope env = { 
  tbl = Hashtbl.create 20;
  level = env.level + 1;
  parent = Some env 
}
@

%XXX
<<[[Symbol.table]] other fields>>=
level  : int;
@
% level is for?

%\section{Environment}
%

\section{Intermediate tree representation}
% linearized tree

<<type Tree.stm>>=
type stm =
  | EXP    of exp
  | MOVE   of exp * exp
  | SEQ    of stm * stm
  | LABEL  of label
  | CONT   of label * label list
  | JUMP   of exp
  | CJUMP  of exp * label * label
  | RET    of exp
  <<[[Tree.stm]] cases>>
@
% CONT?? JUMP?
% diff with before? have labels and jumps! so closer
% to assembly. No more if, while, for.

<<type Tree.label>>=
type label = Symbol.symbol
@


<<type Tree.exp>>=
and exp =
  | CONST of int
  | BINOP of binop * exp * exp
  | RELOP of relop * exp * exp
  | MEM   of exp * bool
  | TEMP  of temp * bool
  | ESEQ  of stm * exp
  | NAME  of label
  | CALL  of exp * exp list * string option * label option * bool
@
% diff with before? Not much yet.
% hmm not really linearized. 
% unless linearize() actually (ab)use the same structure but with
% extra postconditions on the form of the tree.


<<type Tree.temp>>=
and  temp  = Symbol.symbol
@
% when we will lineraize then binop will have only "basic" children
% in which case intermediate values will be stored in those 'temp'
% variables. so x = 1+2+3; become temp1 = 2+3; temp2 = 1+temp1; x = temp2

<<types Tree.xxxop>>=
and binop = PLUS | MINUS | MUL | DIV
and relop = EQ | NE   | LT | GT | LE | GE
@

\section{Stack frames}

% locals, params, temporaries, all things not handled by
% exp above.

<<type Frame.frame>>=
type frame = { 
  mutable params : (Tree.label * bool) list;
  mutable vars   : (Tree.label * bool) list;
  mutable temps  : (Tree.label * bool) list;
  <<[[Frame.frame]] other fields>>
}
@
% bool?


%XXX
<<[[Frame.frame]] other fields>>=
name           : Tree.label;
level          : int;
mutable size   : int;
@




\chapter{[[main()]]}

<<function Main.main>>=
let main () =
  try
    Option.parse_cmdline();
    compile !Option.inch
  with Error.Error ex ->
    Error.handle_exception ex
@
% see handle_exception in Error appendix

<<toplevel Main._>>=
let _ = 
  main ()
@

<<signature global Option.inch>>=
val inch      : in_channel ref
@
<<command line flags>>=
let inch   = ref stdin
@

\section{Command line processing}

<<signature function Option.parse_cmdline>>=
val parse_cmdline : unit -> unit
@
% main -> <>
<<function Option.parse_cmdline>>=
let parse_cmdline() = 
  Arg.parse options set_input "Usage:"
@


<<constant Option.options>>=
and options = [
  <<command line options>>
  "-help",     Arg.Unit usage, "\tprint this message";
]
@
% will see more command line options later

<<command line flags>>=
let file   = ref ""
@

% main -> parse_cmdline -> Arg.parse -> set_input (as x <- parse_cmdline)
<<function Option.set_input>>=
let set_input s =
  try 
    file := s; 
    inch := open_in s
  with Sys_error err ->
    raise (Arg.Bad ("could not open file " ^ err))
@



\section{[[Main.compile()]]}

<<function Main.compile>>=
let compile ch =
  (* parsing *)
  let lexbuf = Lexing.from_channel ch in
  let ast = Parser.program Lexer.token lexbuf in
  <<[[Main.compile()]] if dump AST option>>

  (* checking and compiling part1 *)
  let base_env = Environment.new_env base_tenv base_venv in
  let xs = Semantics.translate base_env ast in

  (* compiling part2 and generating *)
  <<[[Main.compile()]] generate headers>>
  xs |> List.iter emit_function 
@

<<signature function Lexer.token>>=
val token : Lexing.lexbuf -> Parser.token
@

%signature Parser.program is actually in generated file parser.mli
% so orphaned chunk below
<<signature function Parser.program>>=
val program :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Ast.exp
@


<<signature function Environment.new_env>>=
val new_env : (string * vartype) list ->
              (string * string option * vartype list * vartype) list -> t
@
% type defs, function defs (string option?)

<<signature function Semantics.translate>>=
val translate : Environment.t -> Ast.exp -> (Frame.frame * Tree.exp) list
@
% one for each function

\section{[[Main.emit_function()]]}


<<function Main.emit_function>>=
let emit_function (frm,ex) =
  (* compiling *)
  <<[[Main.emit_function()]] if dump expression tree>>
  let ltree = Canonical.linearize (Tree.EXP ex) in
  <<[[Main.emit_function()]] if dump linearized tree>>
  ltree |> Tree.find_temps |> List.iter (fun (x,p) -> 
    Frame.alloc_temp frm x p |> ignore
  );

  (* generating *)
  Frame.output_header frm;
  Codegen.emit ltree;
  Frame.output_footer frm
@

<<signature function Canonical.linearize>>=
val linearize : Tree.stm -> Tree.stm list
@
% but should use another DS where can more clearly see the restrictions
% on the shape of the tree

<<signature function Tree.find_temps>>=
val find_temps : stm list -> (temp * bool) list
@
% bool?

<<signature function Frame.output_header>>=
val output_header  : frame -> unit
@
<<signature function Frame.output_footer>>=
val output_footer  : frame -> unit
@

<<signature Codegen.emit>>=
val emit               : Tree.stm list -> unit
@

\chapter{Lexing}

% Lexer.token()

\section{Overview}

<<lexer.mll>>=
{
module E = Error
module P = Parser

<<global Lexer.keyword_table>>
<<function Lexer.escape>>
<<Lexer globals>>
}

<<Lexer aliases>>

<<rule token>>
<<rule comment>>
<<rule string>>
@


<<rule token>>=
rule token = parse
  <<[[Lexer.token]] cases>>
  | eof  { P.EOF }
  | _
      { raise (E.Error(E.Illegal_character (Lexing.lexeme_char lexbuf 0),
                       Lexing.lexeme_start lexbuf)) }
@


%\section{Token}
% can see different concepts already
% in parser.mly but really related to lexing
<<token declarations>>=
%token <string> ID
%token <int> INT
%token <string> STRING
%token IF THEN ELSE END  WHILE DO FOR TO BREAK
%token PLUS MINUS TIMES DIVIDE
%token AND OR
%token EQ NEQ  LT LE GT GE
%token FUNCTION VAR LET IN
%token TYPE OF ARRAY
%token ASSIGN COLON COMMA DOT SEMICOLON 
%token LPAREN RPAREN  LBRACE RBRACE  LBRACK RBRACK
%token NIL
%token EOF
@


% no position information here, no use of Lexing.lexeme_char()
% but instead use Parsing.symbol_start()


\section{Spaces and newlines}

<<Lexer aliases>>=
let nl = ['\010' '\013']
let blank = [' ' '\009' '\012']
@
% C-j, C-m
% Tab (C-i), C-l (PageDown)

<<Lexer globals>>=
let line_num = ref 0
@

<<[[Lexer.token]] cases>>=
|  nl   { incr line_num;
         E.add_source_mapping (Lexing.lexeme_end lexbuf) !line_num;
         token lexbuf }
| blank + { token lexbuf }
@
%E = Error
% important for error reporting, see appendix

\section{Comments}

<<[[Lexer.token]] cases>>=
| "/*" { comment lexbuf; token lexbuf }
@
% call back original rule

<<Lexer globals>>=
let comment_pos = Stack.create()
@

% nested comment handling, but not single line comment :(
<<rule comment>>=
and comment = parse
    "/*" { Stack.push (Lexing.lexeme_start lexbuf) comment_pos;
           comment lexbuf; }
  | "*/" { try (ignore(Stack.pop comment_pos); comment lexbuf)
           with Stack.Empty -> () }
  | nl   { incr line_num;
           E.add_source_mapping (Lexing.lexeme_end lexbuf) !line_num;
           comment lexbuf }
  | eof  { let st = Stack.top comment_pos in
           raise (E.Error(E.Unterminated_comment, st)) }
  | _    { comment lexbuf }
@

\section{Identifiers and keywords}

<<Lexer aliases>>=
let letter = ['A'-'Z' 'a'-'z']
let identchar = ['A'-'Z' 'a'-'z' '_' '0'-'9']
@

<<[[Lexer.token]] cases>>=
| letter identchar *
    { let s = Lexing.lexeme lexbuf in
      try
        Hashtbl.find keyword_table s
      with Not_found ->
        P.ID s 
    }
@


<<global Lexer.keyword_table>>=
(* The table of keywords *)
let keyword_table = Hashtbl.create 22;;
List.iter (fun (key, data) -> Hashtbl.add keyword_table key data)
  [
   "if",        P.IF;
   "then",      P.THEN;
   "else",      P.ELSE;
   "while",     P.WHILE;
   "do",        P.DO;
   "for",       P.FOR;
   "to",        P.TO;
   "end",       P.END;
   "break",     P.BREAK;

   "function",  P.FUNCTION;
   "var",       P.VAR;
   "let",       P.LET;
   "in",        P.IN;

   "type",      P.TYPE;
   "of",        P.OF;
   "array",     P.ARRAY;

   "and",       P.AND;
   "or",        P.OR;

   "nil",       P.NIL;

   <<[[Lexer.keyword_table]] entries>>
 ];;
@
% no pointers, no class, no ADTs, very basic indeed.

\section{Operators}

<<[[Lexer.token]] cases>>=
| "+"  { P.PLUS }
| "-"  { P.MINUS }
| "*"  { P.TIMES }
| "/"  { P.DIVIDE }

| "&"  { P.AND }
| "|"  { P.OR }

| "="  { P.EQ }
| "<>" { P.NEQ }

| ">"  { P.GT }
| "<"  { P.LT }
| ">=" { P.GE }
| "<=" { P.LE }
@



\section{Punctuations}

<<[[Lexer.token]] cases>>=
| ":=" { P.ASSIGN }
| ":"  { P.COLON }
| ","  { P.COMMA }
| "."  { P.DOT }
| ";"  { P.SEMICOLON }

| "{"  { P.LBRACE } | "}"  { P.RBRACE }
| "["  { P.LBRACK } | "]"  { P.RBRACK }
| "("  { P.LPAREN } | ")"  { P.RPAREN }
@

\section{Numbers}

<<Lexer aliases>>=
let number = ['0'-'9']
@

<<[[Lexer.token]] cases>>=
| number +
    { P.INT (int_of_string(Lexing.lexeme lexbuf)) }
@

% no float ?


\section{Strings}

% no chars? no unicode?

<<[[Lexer.token]] cases>>=
| "\"" 
    { string_start_pos := Lexing.lexeme_start lexbuf;
      P.STRING (string lexbuf) }
@

<<Lexer globals>>=
let string_start_pos = ref 0
let buffer = Buffer.create 30
@


<<rule string>>=
and string = parse
    '"'
      { Buffer.contents buffer }
  | '\\' ['\\' '\'' '"' 'n' 't' 'b' 'r']
      { Buffer.add_char buffer (escape (Lexing.lexeme_char lexbuf 1));
        string lexbuf }
  | [^ '"' '\\'] +
      { Buffer.add_string buffer (Lexing.lexeme lexbuf);
        string lexbuf }
  | eof
      { raise (E.Error(E.Unterminated_string, !string_start_pos)) }
@
%old:      { let s = Buffer.contents buffer in
%        (Buffer.clear buffer; s) }

<<function Lexer.escape>>=
(* To buffer string literals *)
let escape c = 
  match c with
  | 'n' -> '\n'
  | 'r' -> '\r'
  | 'b' -> '\b'
  | 't' -> '\t'
  | _ -> c
@







\chapter{Parsing}

% Parser.program()

\section{Overview}

<<parser.mly>>=
%{
module E = Error
module A = Ast
module S = Symbol

<<parser helper functions>>
<<AST mk wrappers>>
%}

/* Tokens */
<<token declarations>>

/* Precedences and associativities (from low to high) */
<<token priorities>>

/* start symbols */
%start program
<<rule type declarations>>

/* %expect 63 */

%%
<<grammar>>
@ 
% 63 conflicts??? actually gets 66


<<grammar>>=
<<rule program>>

/* Expressions */
<<rule expr>>
<<rule lvalue>>
<<subrules for expr>>
<<subrules for stmt>>

/* Declarations */
<<rule decs>>
<<subrules for decs>>

/* Types */
<<rule ty>>
<<subrules for ty>>

/* Names */
<<rule id>>
@







<<rule type declarations>>=
%type <Ast.exp> program
%type <Ast.exp> expr
%type <Ast.var> lvalue
%type <Ast.dec list> decs
@
% Parser.program, it's here!



<<rule program>>=
program:
  expr EOF { $1 }
@
%$

<<rule expr>>=
expr:
  LET decs IN expr_list END { mkLetExp $2 (mkSeqExp $4) }
@






\section{Declarations}

<<rule decs>>=
/* recursive declarations in tiger.
   My interpretation of the tiger language spec is that
   mutally recursive types and functions are valid if they
   are declared together in a sequence. That is:
   type a = {b:int c:d} type d = a
   is valid where as 
   type a = {b:int c:d} var x := 1 type d = a
   is not.
*/
decs:
   dec { $1 :: [] }
 | dec decs { $1 :: $2 }
@
%$

<<subrules for decs>>=
<<rule dec>>
<<rule var_dec>>
<<rule type_decs>>
<<rule fun_decs>>
<<rule exn_dec>>
@

<<rule dec>>=
dec:
   var_dec   { $1 }
 | type_decs { mkTypeDec $1 }
 | fun_decs  { mkFunctionDec $1 }
 | exn_dec   { $1 }
@



\subsection{Variables}

%<<[[Ast.dec]] cases>>=
%| VarDec       of symbol * symbol option * exp * pos
%@

<<rule var_dec>>=
var_dec:
   VAR id ASSIGN expr          { mkVarDec $2 None $4 }
 | VAR id COLON id ASSIGN expr { mkVarDec $2 (Some $4) $6 }
@
%$

\subsection{Types}

%<<[[Ast.dec]] cases>>=
%| TypeDec      of (symbol * ty * pos) list
%@
% list so can have mutually recursive things

<<rule type_decs>>=
type_decs:
   type_dec           { $1 :: [] }
 | type_dec type_decs { $1 :: $2 }
;
type_dec:
   TYPE id EQ ty { mkTyDec $2 $4 }
;
@
%$


\subsection{Functions}

%<<[[Ast.dec]] cases>>=
%| FunctionDec  of (symbol * field list * symbol option * exp * pos) list
%@
% list again for mutually recursive possibilities
% symbol option cos can be a procedure that returns nothing

<<rule fun_decs>>=
fun_decs:
   fun_dec          { $1 :: [] }
 | fun_dec fun_decs { $1 :: $2 }

fun_dec:
   FUNCTION id LPAREN ty_fields RPAREN EQ expr
     { mkFunDec $2 $4 None $7 }
 | FUNCTION id LPAREN ty_fields RPAREN COLON id EQ expr
     { mkFunDec $2 $4 (Some $7) $9 }
@



\section{Expressions}

<<rule expr>>=
 | lvalue                    { mkVarExp $1 }
 | literal                   { $1 }
 | function_call             { $1 }
 | arithmetic                { $1 }
 | comparison                { $1 }
 | boolean                   { $1 }
 | construction              { $1 }
@
%$

% no pointer!

\subsection{Entity uses}

<<rule id>>=
/* Symbols are created in this rule only */
id: ID { S.symbol $1 };
@
%$

\subsection{Local entity definitions}

%expr:
%  LET decs IN expr_list END { mkLetExp $2 (mkSeqExp $4) }
% saw Let in in overview section

%<<[[Ast.exp]] cases>>=
%| LetExp    of dec list * exp * pos
%@

\subsection{Lvalue, array and field accesses}

%<<[[Ast.exp]] cases>>=
%| VarExp    of var
%@

% =~ lvalue
<<type Ast.var>>=
and var =
    SimpleVar    of symbol * pos
  | FieldVar     of var * symbol * pos
  | SubscriptVar of var * exp * pos
@
% no pointer here

<<rule lvalue>>=
/* Variables (L-values) 
   This rule is overly explicit to avoid conflicts with 
   the construction rule below */
lvalue:
 | id                        { mkSimpleVar $1 }
 | id DOT id                 { mkFieldVar (mkSimpleVar $1) $3 }
 | id LBRACK expr RBRACK     { mkSubscriptVar (mkSimpleVar $1) $3 }

 | lvalue DOT id             { mkFieldVar $1 $3 }
 | lvalue LBRACK expr RBRACK { mkSubscriptVar $1 $3 }
@
%$

\subsection{Literals}

%<<[[Ast.exp]] cases>>=
%| NilExp
%| IntExp    of int
%| StringExp of string * pos
%@

<<subrules for expr>>=
/* Literals */
literal:
   NIL    { mkNilExp }
 | INT    { mkIntExp $1 }
 | STRING { mkStringExp $1 }
@

% no float

\subsection{Arithmetic}

<<token priorities>>=
%nonassoc ASSIGN
%left AND OR
%nonassoc EQ NEQ GT LT GE LE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc UMINUS
@


%<<[[Ast.exp]] cases>>=
%| OpExp     of exp * oper * exp * pos
%@

<<type Ast.oper>>=
and oper =
<<[[Ast.oper]] cases>>
@

<<[[Ast.oper]] cases>>=
| PlusOp | MinusOp | TimesOp | DivideOp
@

<<subrules for expr>>=
/* Simple Arithmetic */
arithmetic:
   MINUS expr %prec UMINUS { mkOpExp (mkIntExp 0) $2 A.MinusOp }
 | expr PLUS expr          { mkOpExp $1 $3 A.PlusOp    }
 | expr MINUS expr         { mkOpExp $1 $3 A.MinusOp  }
 | expr TIMES expr         { mkOpExp $1 $3 A.TimesOp  }
 | expr DIVIDE expr        { mkOpExp $1 $3 A.DivideOp }
@

\subsection{Comparison}

<<[[Ast.oper]] cases>>=
| EqOp | NeqOp   
| LtOp | LeOp | GtOp | GeOp
@

<<subrules for expr>>=
/* Comparison */
comparison:
   expr EQ expr  { mkOpExp $1 $3 A.EqOp  }
 | expr NEQ expr { mkOpExp $1 $3 A.NeqOp }
 | expr GT expr  { mkOpExp $1 $3 A.GtOp  }
 | expr LT expr  { mkOpExp $1 $3 A.LtOp  }
 | expr GE expr  { mkOpExp $1 $3 A.GeOp  }
 | expr LE expr  { mkOpExp $1 $3 A.LeOp  }
@

\subsection{Boolean}

<<subrules for expr>>=
/* Boolean operators */
boolean:
   expr AND expr { mkIfExp $1 $3 (Some(mkIntExp 0)) }
 | expr OR expr  { mkIfExp $1 (mkIntExp 1) (Some $3) }
@

% ! short circuiting operators actually!
% abuse int for booleans :( ugly

\subsection{Function calls}

%<<[[Ast.exp]] cases>>=
%| CallExp   of symbol * exp list * pos
%@
% no dynamic funcall! fixed symbol

<<subrules for expr>>=
/* function call */
function_call:
   id LPAREN fun_args RPAREN { mkCallExp $1 $3 }

fun_args:
   /* empty */         { [] }
 | expr                { $1 :: [] }
 | expr COMMA fun_args { $1 :: $3 }
@
%$


\subsection{Construction}

%<<[[Ast.exp]] cases>>=
%| RecordExp of symbol * (symbol * exp * pos) list * pos
%| ArrayExp  of symbol * exp * exp * pos
%@
% why symbol? for type name? =~ new? bot for arrays?

<<subrules for expr>>=
/* Record and array construction */
construction:
   id LBRACE ctor_list RBRACE    { mkRecExp $1 $3 }
 | id LBRACK expr RBRACK OF expr { mkArrayExp $1 $3 $6 }

ctor_list:
   id EQ expr                 { (mkRecFld $1 $3) :: [] }
 | id EQ expr COMMA ctor_list { (mkRecFld $1 $3) :: $5 }
@


\section{Statements}

<<rule expr>>=
 | sequence                  { mkSeqExp $1 }
 | if_statement              { $1 }
 | loop_statement            { $1 }
@
%$


\subsection{Sequence}

%<<[[Ast.exp]] cases>>=
%| SeqExp    of exp list * pos
%@

<<subrules for stmt>>=
/* Sequence expression */
sequence:
   LPAREN RPAREN           { [] }
 | LPAREN expr_list RPAREN { $2 }
@
%$
% paren, meh, as in ocaml, but unusual; should have used LBRACE I think

<<subrules for stmt>>=
expr_list:
   expr                     { $1 :: [] }
 | expr SEMICOLON expr_list { $1 :: $3 }
@
%$

\subsection{Assignments}

%<<[[Ast.exp]] cases>>=
%| AssignExp of var * exp * pos
%@

<<rule expr>>=
 | lvalue ASSIGN expr        { mkAssignExp $1 $3 }
@

\subsection{Conditionals}

%<<[[Ast.exp]] cases>>=
%| IfExp     of exp * exp * exp option * pos
%@

<<subrules for stmt>>=
/* If statements */
if_statement:
   IF expr THEN expr           { mkIfExp $2 $4 None }
 | IF expr THEN expr ELSE expr { mkIfExp $2 $4 (Some $6) }
@
%$

\subsection{Loops}

%<<[[Ast.exp]] cases>>=
%| WhileExp  of exp * exp * pos
%| ForExp    of symbol * exp * exp * exp * pos
%
%| BreakExp  of pos
%@
% no continue?

<<subrules for stmt>>=
/* Loop statements */
loop_statement:
   WHILE expr DO expr                 { mkWhileExp $2 $4 }
 | FOR id ASSIGN expr TO expr DO expr { mkForExp $2 $4 $6 $8 }
 | BREAK                              { mkBreakExp }
@
%$





\section{Types}

%<<[[Ast.ty]] cases>>=
%| NameTy   of symbol * pos
%| RecordTy of field list
%| ArrayTy  of symbol * pos
%@
% namety can be also builtin types!
% no size in ArrayTy, lose information when type


<<rule ty>>=
ty:
   id                      { mkNameTy $1 }
 | LBRACE ty_fields RBRACE { mkRecordTy $2 }
 | ARRAY OF id             { mkArrayTy $3 }

ty_fields:
   /* empty */                 { [] }
 | id COLON id                 { (mkField $1 $3) :: [] }
 | id COLON id COMMA ty_fields { (mkField $1 $3) :: $5 }
@
%$

\ifallcode
\section{Helpers}

<<parser helper functions>>=
let getpos = Parsing.symbol_start
@
% subtle! he does not use the lexer for position tracking (well he used
% it only for the pos -> line tracking) but the lr engine.

%less: could delete, inline
<<AST mk wrappers>>=
let mkField n t           = (n, t, getpos())

let mkSimpleVar v         = A.SimpleVar(v, getpos())
let mkFieldVar v t        = A.FieldVar(v, t, getpos())
let mkSubscriptVar v e    = A.SubscriptVar(v, e, getpos())

let mkNilExp              = A.NilExp
let mkVarExp v            = A.VarExp(v)
let mkIntExp i            = A.IntExp(i)
let mkStringExp s         = A.StringExp(s, getpos())
let mkCallExp f a         = A.CallExp(f, a, getpos())
let mkOpExp l r op        = A.OpExp(l, op, r, getpos())
let mkRecFld n e          = (n, e, getpos())
let mkRecExp n f          = A.RecordExp(n, f, getpos())
let mkSeqExp el           = A.SeqExp(el, getpos())
let mkAssignExp v e       = A.AssignExp(v, e, getpos())
let mkIfExp tst t e       = A.IfExp(tst, t, e, getpos())
let mkWhileExp tst b      = A.WhileExp(tst, b, getpos())
let mkForExp v lo hi body = A.ForExp(v, lo, hi, body, getpos())
let mkBreakExp            = A.BreakExp(getpos())
let mkLetExp decs body    = A.LetExp(decs, body, getpos())
let mkArrayExp v s init   = A.ArrayExp(v, s, init, getpos())

let mkHandler name exp    = (name, exp, getpos())
let mkTryExp exp handlers = A.TryExp(exp, handlers, getpos())
let mkRaise id            = A.RaiseExp(id, getpos())

let mkSpawn id            = A.SpawnExp(id, getpos())

let mkFunDec n f t b      = (n, f, t, b, getpos())
let mkFunctionDec l       = A.FunctionDec(l)
let mkVarDec n t i        = A.VarDec(n, t, i, getpos())
let mkTyDec n t           = (n, t, getpos())
let mkTypeDec l           = A.TypeDec(l)
let mkNameTy n            = A.NameTy(n, getpos())
let mkRecordTy l          = A.RecordTy(l)
let mkArrayTy n           = A.ArrayTy(n, getpos())
let mkException s         = A.ExceptionDec(s, getpos())
@
\fi
%todo: inline? not much gain

\chapter{Checking}

\section{The environment}

<<type Environment.t>>=
type t = {
    (* type definitions *)
    tenv        : vartype Symbol.table;
    (* value definitions *)
    venv        : vartype enventry Symbol.table;
    <<[[Environment.t]] other fields>>
  }
@
%todo: LP split
%old: was 'a but clearer I think to put 'ty or even to directly
% reference vartype!

<<type Environment.enventry>>=
type 'ty enventry =
    VarEntry of (Frame.access * 'ty)
  | FunEntry of (Symbol.symbol * string option * Frame.frame * 'ty list * 'ty)
@ 
% string option = storage, for instance "C"

%XXX
<<[[Environment.t]] other fields>>=
xenv        : int Symbol.table;

frame       : Frame.frame;

break_label : Tree.label option;
@

\section{Builtins}

<<constant Main.base_tenv>>=
let base_tenv =
(* name     type *)
[ "int",    T.INT
; "string", T.STRING
]
@

<<constant Main.base_venv>>=
let base_venv = 
(* name        cc        args                    return *)
[ "print",     Some "C", [T.STRING],             T.UNIT
; "printi",    Some "C", [T.INT],                T.UNIT
; "flush",     Some "C", [],                     T.UNIT
; "getchar",   None,     [],                     T.STRING
; "ord",       Some "C", [T.STRING],             T.INT
; "chr",       None,     [T.INT],                T.STRING
; "size",      Some "C", [T.STRING],             T.INT
; "sizea",     Some "C", [T.ARRAY T.ANY],        T.INT
; "substring", None,     [T.STRING;T.INT;T.INT], T.STRING
; "concat",    None,     [T.STRING;T.STRING],    T.STRING
; "not",       Some "C", [T.INT],                T.INT
; "exit",      Some "C", [T.INT],                T.UNIT
]
@


\section{Typechecking}

% actually typechecking and IR code generation are done together
% (as opposed to ocaml where have typechecking returning a typed
% and named tree first)

\chapter{Intermediate Representation Generation}
%IR generation

\section{Declarations}

\section{Statements}

\section{Expressions}

\chapter{Linearization}

\chapter{[[C--]] Generation}

\section{Header generation}

<<[[Main.compile()]] generate headers>>=
Codegen.output_file_header imports;
Frame.output_strings();
@

\chapter{Runtime}

\section{Standard library}

\section{Startup code}

\section{Garbage collection}

\chapter{Advanced Features}

\section{Typedefs}

<<[[Environment.vartype]] cases>>=
| NAME   of Symbol.symbol
@

<<function Semantics.base_type>>=
let rec base_type env = function
    NAME s ->
      (try base_type env (V.lookup_type env s 0)
       with Not_found -> E.internal "NAME symbol not found"
      )
  | x -> x
@

<<function Semantics.lookup_base_type>>=
let lookup_base_type env sym pos =
  base_type env (V.lookup_type env sym pos)
@ 

\section{Exceptions}

%lexer
<<token declarations>>=
%token EXCEPTION  TRY RAISE HANDLE
@

<<[[Lexer.keyword_table]] entries>>=
"exception", P.EXCEPTION;

"try",       P.TRY;
"handle",    P.HANDLE;
"raise",     P.RAISE;
@



%AST def
<<[[Ast.dec]] cases>>=
| ExceptionDec of symbol * pos
@

%grammar def
<<rule exn_dec>>=
exn_dec:
   EXCEPTION id { mkException $2 }
@
%$
% no arguments in exception

% AST use
<<[[Ast.exp]] cases>>=
| TryExp    of exp * (symbol * exp * pos) list * pos
| RaiseExp  of symbol * pos
@

% grammar user
<<rule expr>>=
 | TRY expr handlers         { mkTryExp $2 (List.rev $3) }
 | RAISE id                  { mkRaise $2 }
@
%$

<<subrules for stmt>>=
/* exception handlers */
handler:
   HANDLE id expr END         { mkHandler $2 $3 }

handlers:
   handler          { $1 :: [] }
 | handler handlers { $1 :: $2 }
@
%$


% typechecking
<<[[Environment.t]] other fields>>=
exn_label   : Tree.label option
@

% generating
<<[[Tree.stm]] cases>>=
  | TRY    of label
  | TRYEND of label
@


<<command line flags>>=
let unwind = ref false
@
<<command line options>>=
"-unwind",   Arg.Set unwind, "\tuse unwind continuations for exceptions";
@


\section{Spawn}
% process?

%AST
<<[[Ast.exp]] cases>>=
| SpawnExp  of symbol * pos
@

%lexer
<<token declarations>>=
%token SPAWN
@
<<[[Lexer.keyword_table]] entries>>=
"spawn",     P.SPAWN;
@

%grammar
<<rule expr>>=
 | SPAWN id                  { mkSpawn $2 }
@
%$

%typechecking, generating

\chapter{Advanced Topics}

\chapter{Conclusion}




\appendix

\chapter{Error Managment}

\section{The errors}

<<type Error.error>>=
type error =
    Internal_error of string

  (* lexical errors *)
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment
  | Unterminated_string

  (* syntaxic errors *)
  | Syntax_error

  (* semantic errors *)
  | Type_error of string
  | Undefined_symbol of string
  | Duplicate_symbol of string
  | Illegal_break
@
%less: rename error_kind

<<type Error.ex>>=
type ex = error * int
@
%less: rename just error, because ex means?

<<exception Error.Error>>=
exception Error of ex
@

%ex:
<<parser helper functions>>=
let parse_error s =
  let pos = getpos() in
  raise (E.Error(E.Syntax_error, pos))
@

<<function Error.type_err>>=
let type_err  pos msg = 
  raise(Error(Type_error msg, pos))
@
<<function Error.undefined>>=
let undefined pos msg = 
  raise(Error(Undefined_symbol msg, pos))
@
<<function Error.internal>>=
let internal      msg = 
  raise(Error(Internal_error msg, 0))
@

<<function Error.handle_exception>>=
let handle_exception (ex,pos) =
  let msg = match ex with
    Internal_error s     -> "Compiler bug: " ^ s

  | Illegal_character ch -> Printf.sprintf "illegal character '%c'" ch
  | Illegal_escape str   -> Printf.sprintf "illegal escape %s" str
  | Unterminated_comment -> "unterminated comment"
  | Unterminated_string  -> "unterminated string"

  | Syntax_error         -> "syntax error"

  | Type_error str       -> str
  | Undefined_symbol str -> "undefined symbol: " ^ str
  | Duplicate_symbol str -> "duplcate definition of: " ^ str
  | Illegal_break        -> "Illegal break statement"
  in
  err_msg "Error" pos msg;
  exit 1
@

% type error dumper, should be the string in Type_error of string above
<<function Semantics.type_name>>=
let rec type_name = function
    RECORD l -> (List.fold_left (fun x y -> x ^ (type_name (snd y)))
                "record {" l) ^ "}"
  | NIL      -> "nil"
  | INT      -> "int"
  | STRING   -> "string"
  | ARRAY vt -> "array of " ^ (type_name vt)
  | NAME(s)  -> "named type " ^ (S.name s)
  | UNIT     -> "unit"
  | ANY      -> "any"
@ 

\section{Line position}

<<function Error.err_msg>>=
let err_msg prefix pos msg =
  let (line,col) = line_number pos in
  if line > 0 
  then
    Printf.fprintf stderr
      "%s:%d,%d: %s\n" !Option.file line col msg
  else
    Printf.fprintf stderr "%s: %s\n" prefix msg
@

<<function Error.warning>>=
let warning = err_msg "Warning"
@


<<function Error.line_number>>=
let line_number pos =
  let rec line ln last_p = function
      (p,l) :: rest ->
        if p > pos then (l, pos - last_p)
        else line l p rest
    | [] -> (ln + 1, pos - last_p)
  in line 0 0 source_map.sm
@



% source map
<<type Error.sm>>=
type sm = { mutable sm: (int * int) list }
@

<<global Error.source_map>>=
let source_map = { sm = [(0,0)] }
@

% should be called by the lexer
<<function Error.add_source_mapping>>=
let add_source_mapping pos line =
  source_map.sm <- source_map.sm @ [(pos,line)]
@
% @? slow?





\chapter{Debugging}

\section{[[tiger -dump_ast]]}

<<command line flags>>=
let dump_ast    = ref false
@
<<command line options>>=
"-dump_ast",      Arg.Set dump_ast,    "\tprint Abstract Syntax Tree";
@

<<[[Main.compile()]] if dump AST option>>=
if !Option.dump_ast
then Ast.print_tree ast;
@


<<function Ast.print_tree>>=
let print_tree expression =
  <<declaration printer>>
  <<type printer>>
  <<variable printer>>
  <<expression printer>>
in exp 0 expression
@

<<function iprintf>>=
let iprintf d fmt =
  let rec indent = function
      0 -> ()
    | i -> (print_string "  "; indent(i-1))
  in (indent d; Printf.printf fmt)
@



<<declaration printer>>=
let rec dec d =
  let print_opt_sym d = function
      None   -> iprintf (d+1) ": NONE\n"
    | Some s -> iprintf (d+1) ": SOME(%s)\n" (S.name s)
  in
  function
    FunctionDec functions ->
      let prfield d (n,t,_) =
        iprintf d "%s:%s\n" (S.name n) (S.name t)
      in
      let prfun d (name, params, type', body, _) =
 iprintf d "%s:\n" (S.name name);
        List.iter (prfield (d+1)) params;
        print_opt_sym (d+1) type';
 exp (d+2) body
      in
      iprintf d "FunctionDec:\n";
      List.iter (prfun (d+1)) functions
  | VarDec(name, type', init,_) ->
      iprintf d "VarDec: %s\n" (S.name name);
      print_opt_sym (d+1) type';
      exp (d+1) init
  | TypeDec types ->
      let prtdec d (name, type',_) =
        iprintf d "%s:\n" (S.name name); ty (d+1) type'
      in
      iprintf d "TypeDec:\n";
      List.iter (prtdec (d+1)) types
  | ExceptionDec(s,_) ->
      iprintf d "ExceptionDec:%s\n" (S.name s)
@
<<type printer>>=
and ty d = function
    NameTy(s,_)     -> iprintf d "NameTy : %s\n" (S.name s)
  | ArrayTy(s,_)    -> iprintf d "ArrayTy: %s\n" (S.name s)
  | RecordTy fields ->
      let f d (n,t,_) =
        iprintf d "%s:%s\n" (S.name n) (S.name t)
      in
      iprintf d "RecordTy:\n";
      List.iter (f (d+1)) fields
@
<<variable printer>>=
and var d = function
    SimpleVar(s,_)      -> iprintf d "SimpleVar: %s\n" (S.name s)
  | FieldVar(v,s,_)     -> iprintf d "FieldVar:\n";
                           var (d+1) v;
                           iprintf (d+1) "%s\n" (S.name s)
  | SubscriptVar(v,e,_) -> iprintf d "SubscriptVar:\n";
                           var (d+1) v;
                           exp (d+1) e
@
<<expression printer>>=
and exp d = function
    VarExp v       -> var d v
  | NilExp         -> iprintf d "NilExp\n"
  | IntExp i       -> iprintf d "IntExp: %d\n" i
  | StringExp(s,_) -> iprintf d "StringExp:%s\n" (String.escaped s)
  | RecordExp(name, fields, _) ->
      let f d (n,e,_) =
        (iprintf d "%s:\n" (S.name n); exp (d+1) e)
      in
      iprintf d "RecordExp: %s\n" (S.name name);
      List.iter (f (d+1)) fields
  | ArrayExp(v, size, init, p) ->
      iprintf d "ArrayExp: %s\n" (S.name v);
      exp (d+1) size;
      exp (d+1) init
  | AssignExp(v, e, _) ->
      iprintf d "AssignExp:\n";
      var (d+1) v;
      exp (d+1) e
  | OpExp(left, oper, right, _) -> 
      iprintf d "OpExp:%s\n" (opname oper);
      exp (d+1) left;
      exp (d+1) right
  | CallExp(name, args, _) ->
      iprintf d "CallExp: %s\n" (S.name name);
      List.iter (exp (d+1)) args
  | IfExp(if', then', else', _) ->
      iprintf d "IfExp:\n";
      exp (d+1) if';
      exp (d+1) then';
      begin match else' with
        None   -> ()
      | Some a -> exp (d+1) a
      end
  | WhileExp(test, body, _) ->
      iprintf d "WhileExp:\n";
      exp (d+1) test;
      exp (d+1) body
  | ForExp(var, lo, hi, body, _) ->
      iprintf d "ForExp: %s\n" (S.name var);
      exp (d+1) lo;
      exp (d+1) hi;
      exp (d+1) body
  | BreakExp _ ->
      iprintf d "BreakExp\n"
  | SeqExp(l, _) ->
      iprintf d "SeqExp:\n"; List.iter (exp (d+1)) l
  | LetExp(decs, body, _) ->
      iprintf d "LetExp:\n";
      List.iter (dec (d+1)) decs;
      iprintf d "IN:\n";
      exp (d+2) body
  | TryExp(expr, handlers, _) ->
      iprintf d "TryExp:\n";
      exp (d+1) expr;
      List.iter
        (fun (n,h,_) -> iprintf (d+2) "%s:\n" (S.name n); exp (d+2) h)
        handlers
  | RaiseExp(name,_) ->
      iprintf d "RaiseExp %s\n" (S.name name)
  | SpawnExp(name,_) ->
      iprintf d "SpawnExp %s\n" (S.name name)
@ 

<<function Ast.opname>>=
let opname = function
    PlusOp   -> "PlusOp"
  | MinusOp  -> "MinusOp"
  | TimesOp  -> "TimesOp"
  | DivideOp -> "DivideOp"
  | EqOp     -> "EqOp"
  | NeqOp    -> "NeqOp"
  | LtOp     -> "LtOp"
  | LeOp     -> "LeOp"
  | GtOp     -> "GtOp"
  | GeOp     -> "GeOp"
@


\section{[[tiger -dump_ext]]}

<<command line flags>>=
let dump_ext    = ref false
@
<<command line options>>=
"-dump_ext",      Arg.Set dump_ext,    "\tprint Expression Trees";
@

<<[[Main.emit_function()]] if dump expression tree>>=
if !Option.dump_ext  
then Tree.print_exp ex;
@


<<function Tree.print_exp>>=
let print_exp e = print_stm (EXP e)
@

<<function Tree.print_stm>>=
let print_stm =
  let rec iprintf = function
      0 -> Printf.printf
    | i -> (print_string "  "; iprintf (i-1))
  in
  let rec prstm d = function
    | LABEL l      -> iprintf d "LABEL:%s\n " (S.name l)
    | CONT(l,ls)   -> iprintf d "CONT:%s\n "  (S.name l)
    | TRY l        -> iprintf d "TRY:%s\n"    (S.name l)
    | TRYEND l     -> iprintf d "TRYEND:%s\n" (S.name l)
    | SEQ(a,b)     -> iprintf d "SEQ:\n";     prstm(d+1) a; prstm(d+1) b
    | MOVE(a,b)    -> iprintf d "MOVE:\n";    prexp(d+1) a; prexp(d+1) b
    | JUMP e       -> iprintf d "JUMP:\n";    prexp(d+1) e
    | EXP e        -> iprintf d "EXP:\n";     prexp(d+1) e
    | RET e        -> iprintf d "RET:\n";     prexp(d+1) e
    | CJUMP(a,t,f) -> iprintf d "CJUMP:\n";   prexp(d+1) a;
                      iprintf (d+1) "true  label: %s\n" (S.name t);
                      iprintf (d+1) "false label: %s\n" (S.name f)
  and prexp d = function
      BINOP(p,a,b)     -> iprintf d "BINOP:%s\n" (cmm_binop p);
                          prexp (d+1) a; prexp (d+1) b
    | RELOP(p,a,b)     -> iprintf d "RELOP:%s\n" (cmm_relop p);
                          prexp (d+1) a; prexp (d+1) b
    | MEM(e,_)         -> iprintf d "MEM:\n"; prexp (d+1) e
    | TEMP(t,_)        -> iprintf d "TEMP %s\n" (S.name t)
    | ESEQ(s,e)        -> iprintf d "ESEQ:\n";
                          prstm (d+1) s; prexp (d+1) e
    | NAME lab         -> iprintf d "NAME %s\n" (S.name lab)
    | CONST i          -> iprintf d "CONST %d\n" i
    | CALL(e,el,_,_,_) -> iprintf d "CALL:\n";
                          prexp (d+1) e; List.iter (prexp (d+2)) el
  in prstm 0
@

\section{[[tiger -dump_lext]]}

<<command line flags>>=
let dump_lext   = ref false
@
<<command line options>>=
"-dump_lext",     Arg.Set dump_lext,   "\tprint Linearized Expression Trees";
@

<<[[Main.emit_function()]] if dump linearized tree>>=
if !Option.dump_lext 
then List.iter Tree.print_stm ltree;
@



\chapter{Extra Code}

\ifallcode
#include "Tiger_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

